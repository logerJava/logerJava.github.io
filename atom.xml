<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>logerJava</title>
  
  
  <link href="http://logerjava.github.io/atom.xml" rel="self"/>
  
  <link href="http://logerjava.github.io/"/>
  <updated>2022-11-08T05:46:29.808Z</updated>
  <id>http://logerjava.github.io/</id>
  
  <author>
    <name>loger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 主从复制</title>
    <link href="http://logerjava.github.io/2022/11/08/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://logerjava.github.io/2022/11/08/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2022-11-08T05:32:44.000Z</published>
    <updated>2022-11-08T05:46:29.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ol><li><p>当 Master 节点进行 insert、update、delete 操作时，会按顺序写入到 binlog 中</p></li><li><p>salve 从库连接 master 主库，Master 有多少个 slave 就会创建多少个 binlog dump 线程</p></li><li><p>当 Master 节点的 binlog 发生变化时，binlog dump 线程会通知所有的 salve 节点，并将相应的 binlog 内容推送给 slave 节点</p></li><li><p>I&#x2F;O 线程接收到 binlog 内容后，将内容写入到本地的 relay-log</p></li><li><p>SQL 线程读取 I&#x2F;O 线程写入的 relay-log，并且根据 relay-log   的内容对从数据库做对应的操作</p></li></ol><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/MySQLCopyTheory.png" alt="主从原理"></p><p>这里有很重要的两个问题 : </p><ul><li>从库同步主库数据的过程是串行化的, 也就是说主库上并行的操作, 在从库上会串行化执行, 由于从库从主库拷贝日志以及串行执行 SQL 的特点, 在高并发场景下, 从库的数据势必会比主库慢, 存在延迟, 所以经常出现刚写入主库的数据读不到的情况</li><li>如果主库突然宕机, 此时数据还没有同步到从库, 那么有些数据从库上是没有的, 会出现数据丢失情况</li></ul><p>MySQL 存在两个机制解决上面的问题 :</p><ul><li>半同步复制 : 主要解决主库数据丢失问题, 也叫做 semi-sync 复制, 指主库写入 binlog 日志之后, 就会强制将此时的数据立即同步到从库, 从库将日志写入自己本地的 relay log 之后, 返回一个 ack 给主库, 主库接收到至少一个从库的 ack 才会认为写操作完成了</li><li>并行复制 : 主要解决同步延时问题, 指从库开启多线程, 并行读取 relay log 中不同库的日志, 然后并行重放不同库的日志, 这是库级别的并行</li></ul><h2 id="如何实现主从复制"><a href="#如何实现主从复制" class="headerlink" title="如何实现主从复制"></a>如何实现主从复制</h2><p>这里举例是一主一从</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>登录 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.1.30.113 是 slave 从机的 IP</span></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;root&#x27;@&#x27;10.1.30.113&#x27; identified by &#x27;1qaz@WSX&#x27;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新系统权限表的配置</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>在 etc&#x2F;my.cnf 增加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启binlog</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=114</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要同步的数据库，如果不配置则同步全部数据库</span></span><br><span class="line">binlog-do-db=test_db</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">binlog日志保留的天数，清除超过10天的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止日志文件过大，导致磁盘空间不足</span></span><br><span class="line">expire-logs-days=10</span><br></pre></td></tr></table></figure><p>重启 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p>通过下方命令查看当前 binlog 日志信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status\G;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/MasterShow.png" alt="MasterShow"></p><h3 id="Slave"><a href="#Slave" class="headerlink" title="Slave"></a>Slave</h3><p>在 etc&#x2F;my.cnf 增加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不要和其他mysql服务<span class="built_in">id</span>重复即可</span></span><br><span class="line">server-id=114</span><br></pre></td></tr></table></figure><p>登录 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入以下命令 : </p><p>MASTER_HOST : 主机 IP</p><p>MASTER_USER: 之前创建的用户账号</p><p>MASTER_PASSWORD : 之前创建的用户密码</p><p>MASTER_LOG_FILE : master 主机的 binlog 日志名称</p><p>MASTER_LOG_POS : binlog 日志偏移量</p><p>master_port : 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;10.1.30.114&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;1qaz@WSX&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000007&#x27;,MASTER_LOG_POS=862,master_port=3306;</span><br></pre></td></tr></table></figure><p>重新启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>启动下方命令校验</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/SlaveShow.png" alt="SlaveShow"></p><p>判断同步成功方式 :</p><ol><li>首先 Master_Log_File 和 Relay_Master_Log_File 所指向的文件必须一致</li><li>其次 Relay_Log_Pos 和 Exec_Master_Log_Pos 的为止也要一致才行</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_role` (</span><br><span class="line">  `role_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">  `state` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;1启用0停用,默认0&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`role_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>在 master 执行上述 SQL 同步到 slave , 表示配置成功</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/MySQLCopyResoultShow.png" alt="MySQLCopyResoultShow"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>配置失败出现的问题常见于 Slave_IO_Running: No 或 Slave_SQL_Running: No , 通常是配置读取文件出现问题或事务回滚造成的主从问题, 由于问题很多不做赘述, 列举几个类似问题的博客 :</p><p><a href="https://blog.csdn.net/zzddada/article/details/113352717">https://blog.csdn.net/zzddada/article/details/113352717</a></p><p><a href="https://blog.csdn.net/weixin_30657999/article/details/99613614">https://blog.csdn.net/weixin_30657999/article/details/99613614</a></p><p><a href="https://blog.csdn.net/lihuarongaini/article/details/101299375">https://blog.csdn.net/lihuarongaini/article/details/101299375</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主从复制原理&quot;&gt;&lt;a href=&quot;#主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;主从复制原理&quot;&gt;&lt;/a&gt;主从复制原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当 Master 节点进行 insert、update、delete 操作时，会按顺序写入</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用消息队列, 优缺点, 各消息队列对比</title>
    <link href="http://logerjava.github.io/2022/11/07/whyMQ/"/>
    <id>http://logerjava.github.io/2022/11/07/whyMQ/</id>
    <published>2022-11-07T07:53:14.000Z</published>
    <updated>2022-11-08T02:19:55.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%A7%A3%E8%80%A6.png" alt="jieou"></p><p>如上方场景, A 系统通过接口调用方式发送数据到 B, C, D 系统, 此时新增 E 系统也需要此数据该如何解决 ? 此时又新增了其他系统呢 ? B 系统在某个时间节点不需要 A 系统的数据了该如何解决 ?</p><p>在上方场景中 A 系统不仅和 B, C, D 等系统严重耦合在一起, 并且要时刻考虑其他系统的状态, 如果宕机是否要重新发送, 是否需要存储消息等, 负责人的讲 A 系统负责人会很痛苦</p><p>如果改用 MQ 方式处理, A 系统产生数据, 直接发送到 MQ 中, 其余需要数据的系统到 MQ 中消费, B 系统不需要则取消消费, 这种情况下 A 系统就摆脱了束缚, 无需考虑调用是否成功, 是否超时等问题, 如下图</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%A7%A3%E8%80%A62.png" alt="jieou2"></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%BC%82%E6%AD%A5.png" alt="yibu"></p><p>如上场景, 假设 A 系统接收到用户请求需要本地持久化数据, 过程为 3ms, 后 B, C, D 写库总计 3 + 300 + 450 + 200 &#x3D; 953ms, 总体接近 1s, 在一般的项目中我们要求基本上是请求响应基本上是对用户无感知的, 大概 200ms 以内完成, 以上情况很难接受</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%BC%82%E6%AD%A52.png" alt="yibu2"></p><p>此时添加 MQ, A 系统发送三条消息到 MQ 中耗时 5ms, 总计 3 + 5 &#x3D; 8ms, 直接返回后续操作在后台完成</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>考虑如下场景, 从早晨 0:00 开始到下午 13:00, 系统 A 每秒并发请求基本维持在 30 左右, 在 13:00 到 14:00 每秒请求激增到 5k+, 系统基于 MySQL 直连, 这时会有每秒 5k+ 的请求打入数据库</p><p>一般的 MySQL 很明显无法抗住这种请求级别, 2k 左右大概是极限, 很可能直接宕机, 用户也就无法继续操作系统, 但是经过高峰期后又再度恢复为每秒 30 的请求量</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%89%8A%E5%B3%B0.png" alt="xuefeng"></p><p>这个时候我们考虑接入 MQ 处理, 每秒 5k+ 的请求写入 MQ, 系统 A 每秒至多处理 2k 的请求, 那么就仅拉取 2k 的请求, 只要不超过处理极限就可以, 这样在最高峰值期间服务并不会挂掉, 每秒 5k 左右的请求进入 MQ, 2k 左右的请求被消费, 这样可能会导致几十万甚至百万的请求积压在 MQ 中, 但是短暂的积压是没有关系的, 经历过高峰期后只有每秒 30 的请求量, 但是系统还是在按照每秒 2k 左右的速度消费, 高峰期过后用不了多久就可以处理结束</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%89%8A%E5%B3%B02.png" alt="xuefeng2"></p><h2 id="消息队列的优缺点"><a href="#消息队列的优缺点" class="headerlink" title="消息队列的优缺点"></a>消息队列的优缺点</h2><p>优点 :</p><ul><li>解耦, 异步, 削峰</li></ul><p>缺点 :</p><ul><li>可用性降低 : 系统引入的外部依赖越多则可用性越低, 根据上面的场景, 本身是 A, B, C, D 四个系统的问题, 接入 MQ 后需要考虑 MQ 的维护问题, 如果 MQ 宕机则整套系统都将崩溃</li><li>复杂度提高 : 新增 MQ 后需要考虑消息幂等问题(是否重复), 消息丢失问题, 顺序等</li><li>一致性问题 : 在将消息发送到 MQ 后返回成功, 但是不一定真的全部成功, 有可能 B, C 写入成功而 D 却失败等问题, 会导致数据不一致</li></ul><p>综上所属消息队列实际上并没有想象的那么简单, 引入消息队列确实可以带来好处, 但是也会衍生出另一些问题, 针对某些必要使用 MQ 的场景我们需要提前准备问题的解决方案, 难度系统直线上升, 但是关键时刻消息队列是起决定性作用的技术, 该用还是要用</p><h2 id="ActiveMQ、RabbitMQ、RocketMQ、Kafka-对比"><a href="#ActiveMQ、RabbitMQ、RocketMQ、Kafka-对比" class="headerlink" title="ActiveMQ、RabbitMQ、RocketMQ、Kafka 对比"></a>ActiveMQ、RabbitMQ、RocketMQ、Kafka 对比</h2><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>以前很多人用 ActiveMQ , 但是现在用的很少, 并且社区不活跃, 不建议使用</p><p>RabbitMQ 社区很活跃, 但是 erlang 语言导致 RabbitMQ 处于基本不可控的状态, 也无法做到自定义</p><p>RocketMQ 来自阿里, 质量有保证, 毕竟有双 11 检验, 但是目前 RocketMQ 已经捐献给 <a href="https://github.com/apache/rocketmq">Apache</a>, 并且活跃度不是很高, 不过毕竟是 Java 写的可控性还是有的, 如果对公司技术自信的可以考虑</p><p>Kafka 一般适用于大数据领域, 日志采集, 实时计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么使用消息队列&quot;&gt;&lt;a href=&quot;#为什么使用消息队列&quot; class=&quot;headerlink&quot; title=&quot;为什么使用消息队列&quot;&gt;&lt;/a&gt;为什么使用消息队列&lt;/h2&gt;&lt;h3 id=&quot;解耦&quot;&gt;&lt;a href=&quot;#解耦&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="消息队列" scheme="http://logerjava.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
