<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>logerJava</title>
  
  
  <link href="http://logerjava.github.io/atom.xml" rel="self"/>
  
  <link href="http://logerjava.github.io/"/>
  <updated>2022-11-09T06:06:56.971Z</updated>
  <id>http://logerjava.github.io/</id>
  
  <author>
    <name>loger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KeyTool 工具生成密钥对</title>
    <link href="http://logerjava.github.io/2022/11/09/KeyTool-%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9/"/>
    <id>http://logerjava.github.io/2022/11/09/KeyTool-%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9/</id>
    <published>2022-11-09T05:56:50.000Z</published>
    <updated>2022-11-09T06:06:56.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生成-JKS"><a href="#生成-JKS" class="headerlink" title="生成 JKS"></a>生成 JKS</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias *** -keyalg RSA -keypass *** -keystore xxx.jks -storepass *** -keystore xxx.jks</span><br></pre></td></tr></table></figure><h3 id="查看-JKS-生成的证书详细信息"><a href="#查看-JKS-生成的证书详细信息" class="headerlink" title="查看 JKS 生成的证书详细信息"></a>查看 JKS 生成的证书详细信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -v -keystore xxx.jks</span><br></pre></td></tr></table></figure><h3 id="导出-cer-证书"><a href="#导出-cer-证书" class="headerlink" title="导出 cer 证书"></a>导出 cer 证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -alias *** -exportcert -keystore xxx.jks -file xxx.cer</span><br></pre></td></tr></table></figure><h3 id="导出公钥-此处命令需要-OpenSSL-并配置环境变量"><a href="#导出公钥-此处命令需要-OpenSSL-并配置环境变量" class="headerlink" title="导出公钥, 此处命令需要 OpenSSL , 并配置环境变量"></a>导出公钥, 此处命令需要 OpenSSL , 并配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -rfc --keystore xxx.jks | openssl x509 -inform pem -pubkey</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/KeyTool%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5.png" alt="keytools生成密钥"></p><p>拷贝出公钥</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;生成-JKS&quot;&gt;&lt;a href=&quot;#生成-JKS&quot; class=&quot;headerlink&quot; title=&quot;生成 JKS&quot;&gt;&lt;/a&gt;生成 JKS&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
    <category term="Tools" scheme="http://logerjava.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 JDK</title>
    <link href="http://logerjava.github.io/2022/11/09/Linux-%E5%AE%89%E8%A3%85-JDK/"/>
    <id>http://logerjava.github.io/2022/11/09/Linux-%E5%AE%89%E8%A3%85-JDK/</id>
    <published>2022-11-09T05:56:00.000Z</published>
    <updated>2022-11-09T05:56:22.285Z</updated>
    
    <content type="html"><![CDATA[<p>下载 tar.gz 包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压到指定位置</span><br><span class="line">tar -zxvf jdk.tar.gz -C /目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量</span><br><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/jdk/jdk1.8.0_311</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATH</span><br><span class="line">export JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/bin</span><br><span class="line">export PATH=$PATH:$&#123;JAVA_PATH&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">让配置文件立即生效, 不行就重启</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>javac, java -verison 测试是否成功</p><p>echo $PATH 查看环境变量是否正确</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下载 tar.gz 包&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://logerjava.github.io/tags/Java/"/>
    
    <category term="Linux" scheme="http://logerjava.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 集群部署 Nacos</title>
    <link href="http://logerjava.github.io/2022/11/09/Linux-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-Nacos/"/>
    <id>http://logerjava.github.io/2022/11/09/Linux-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-Nacos/</id>
    <published>2022-11-09T05:55:13.000Z</published>
    <updated>2022-11-09T05:55:45.354Z</updated>
    
    <content type="html"><![CDATA[<p>在 nacos.io 下载 tar.gz 包, 导入 linux 解压</p><p>因为 nacos 集群部署, 各个节点配置信息需要一致, 所以采取 MySQL 持久化</p><p>找到 &#x2F;conf 下的 nacos-mysql.sql 文件, 在 MySQL 执行</p><p>修改 application.properties 文件, 添加如下配置 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line"></span><br><span class="line">db.num=1</span><br><span class="line"></span><br><span class="line">db.url.0=jdbc:mysql://10.1.30.114:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=1qaz@WSX</span><br></pre></td></tr></table></figure><p>在 &#x2F;conf 下 的 cluster.conf 文件, 添加节点 ip 和 port, 例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.1.30.111:8848</span><br><span class="line">10.1.30.112:8848</span><br><span class="line">10.1.30.113:8848</span><br></pre></td></tr></table></figure><p>启动 nacos</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><p>如果出现 oom 问题, 编辑 startup.sh, 调整 jvm 内存 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m</span><br></pre></td></tr></table></figure><p>如果出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nacos Server did not start because dumpservice bean construction failure :</span><br><span class="line">No DataSource set</span><br></pre></td></tr></table></figure><p>原因可能是因为 MySQL 没有给当前 ip 开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to root@&quot;xxx.xxx.xxx.xxx&quot; identified by &quot;1qaz@WSX&quot;;</span><br></pre></td></tr></table></figure><p>如果在浏览器无法访问, 可能原因是端口未在防火墙开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 8848 -j ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 nacos.io 下载 tar.gz 包, 导入 linux 解压&lt;/p&gt;
&lt;p&gt;因为 nacos 集群部署, 各个节点配置信息需要一致, 所以采取 MySQL 持久化&lt;/p&gt;
&lt;p&gt;找到 &amp;#x2F;conf 下的 nacos-mysql.sql 文件, 在 MySQ</summary>
      
    
    
    
    
    <category term="Java" scheme="http://logerjava.github.io/tags/Java/"/>
    
    <category term="Linux" scheme="http://logerjava.github.io/tags/Linux/"/>
    
    <category term="Nacos" scheme="http://logerjava.github.io/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装 MySQL</title>
    <link href="http://logerjava.github.io/2022/11/09/Linux-%E5%AE%89%E8%A3%85-MySQL/"/>
    <id>http://logerjava.github.io/2022/11/09/Linux-%E5%AE%89%E8%A3%85-MySQL/</id>
    <published>2022-11-09T05:54:14.000Z</published>
    <updated>2022-11-09T05:54:43.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-Mysql"><a href="#安装-Mysql" class="headerlink" title="安装 Mysql"></a>安装 Mysql</h1><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装 MySQL</span><br><span class="line">curl https://webfile.newbanker.cn/mysql/install_centos7.sh -q | bash -s</span><br><span class="line"></span><br><span class="line">记录临时密码</span><br><span class="line"></span><br><span class="line">登录mysql修改mysql密码 </span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">输入数据安装后显示的密码</span><br><span class="line">set password for root@&#x27;localhost&#x27;=password(&#x27;1qaz@WSX&#x27;);</span><br></pre></td></tr></table></figure><h2 id="可能会遇到得问题"><a href="#可能会遇到得问题" class="headerlink" title="可能会遇到得问题"></a>可能会遇到得问题</h2><h3 id="SELinux-linux服务器的安全策略问题"><a href="#SELinux-linux服务器的安全策略问题" class="headerlink" title="SELinux linux服务器的安全策略问题"></a>SELinux linux服务器的安全策略问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can&#x27;t create test file /data/mysql/test-mysql.lower-test</span><br></pre></td></tr></table></figure><p>安全策略问题, 可临时关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><p>永久关闭需要修改配置文件，重启机器：</p><p>修改&#x2F;etc&#x2F;selinux&#x2F;config 文件</p><p>将SELINUX&#x3D;enforcing改为SELINUX&#x3D;disabled</p><h3 id="MySQL-不允许远程连接"><a href="#MySQL-不允许远程连接" class="headerlink" title="MySQL 不允许远程连接"></a>MySQL 不允许远程连接</h3><p>可能导致的原因 :</p><ul><li><p>网络不通</p></li><li><p>服务未启动</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start;</span><br></pre></td></tr></table></figure><ul><li>防火墙端口未开放</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看网络端口信息</span><br><span class="line">netstat -ntp</span><br><span class="line"></span><br><span class="line">查看防火墙状态,查看3306端口</span><br><span class="line">iptables -vnL</span><br></pre></td></tr></table></figure><p>如果3306如下，是drop状态，或者根本无3306端口，说明3306端口设置问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加需要监听的端口</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><ul><li>MySQL 没有允许远程登陆</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root 权限登录</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line">查看是否只有 localhost 主机</span><br><span class="line">select user,host from user;</span><br></pre></td></tr></table></figure><p>如果只有 localhost 主机, 那么把需要远程连接的添加到这里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to root@&quot;xxx.xxx.xxx.xxx&quot; identified by &quot;1qaz@WSX&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装-Mysql&quot;&gt;&lt;a href=&quot;#安装-Mysql&quot; class=&quot;headerlink&quot; title=&quot;安装 Mysql&quot;&gt;&lt;/a&gt;安装 Mysql&lt;/h1&gt;&lt;h2 id=&quot;执行脚本&quot;&gt;&lt;a href=&quot;#执行脚本&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Linux" scheme="http://logerjava.github.io/tags/Linux/"/>
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>ShardingSphere-JDBC 读写分离</title>
    <link href="http://logerjava.github.io/2022/11/09/ShardingSphere-JDBC-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://logerjava.github.io/2022/11/09/ShardingSphere-JDBC-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</id>
    <published>2022-11-09T05:42:40.000Z</published>
    <updated>2022-11-09T06:02:38.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要读写分离"><a href="#为什么要读写分离" class="headerlink" title="为什么要读写分离 ?"></a>为什么要读写分离 ?</h2><p>随着我们系统的业务量扩展, 原有的单机 MySQL 肯定会发生 I&#x2F;O 频率过高等问题, 导致损失性能, 采用主从复制, 读写分离可以提高数据库的可用性, 以及利用率</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>读写分离有很多种实现方式, 比如 AOP 的方式通过方法名判断是读操作还是写操作, 进而使用 master 或 slave , 但是本着不重复造轮子的原则, 以及现有框架成熟度很高我们采取 Apache 的 ShardingSphere-JDBC 框架, 该框架不仅可以实现读写分离, 还有很多其他便利功能, 这里仅对读写分离进行简单讲解</p><p>ShardingSphere-JDBC 官方文档 - <a href="https://shardingsphere.apache.org/document/current/cn/overview/">https://shardingsphere.apache.org/document/current/cn/overview/</a></p><h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>pom 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><p>这里采用一主一从</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master,slave</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://10.1.30.114:3306/test-db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">1qaz@WSX</span></span><br><span class="line">      <span class="attr">slave:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://10.1.30.113:3306/test-db?useUnicode=true&amp;characterEncoding=utf8&amp;tinyInt1isBit=false&amp;useSSL=false&amp;serverTimezone=GMT</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">1qaz@WSX</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql.show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">masterslave:</span></span><br><span class="line">      <span class="attr">load-balance-algorithm-type:</span> <span class="string">round_robin</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">master-slave-rules:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">master-data-source-name:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">slave-data-source-names:</span> <span class="string">slave</span></span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动看到如下提示则代表配置成功</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%BB%E4%BB%8E%E5%90%AF%E5%8A%A8.png" alt="主从启动"></p><h2 id="读写接口测试"><a href="#读写接口测试" class="headerlink" title="读写接口测试"></a>读写接口测试</h2><p>我们编写两个简单的读写接口</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3.png" alt="测试接口"></p><p>使用 postman 请求访问, 可以看到 insert 走的是 master, select 走的是 slave</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%86%99%E6%B5%8B%E8%AF%95.png" alt="写测试"></p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E8%AF%BB%E6%B5%8B%E8%AF%95.png" alt="读测试"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要读写分离&quot;&gt;&lt;a href=&quot;#为什么要读写分离&quot; class=&quot;headerlink&quot; title=&quot;为什么要读写分离 ?&quot;&gt;&lt;/a&gt;为什么要读写分离 ?&lt;/h2&gt;&lt;p&gt;随着我们系统的业务量扩展, 原有的单机 MySQL 肯定会发生 I&amp;#x2F;O 频</summary>
      
    
    
    
    
    <category term="Java" scheme="http://logerjava.github.io/tags/Java/"/>
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Explain</title>
    <link href="http://logerjava.github.io/2022/11/09/MySQL-Explain/"/>
    <id>http://logerjava.github.io/2022/11/09/MySQL-Explain/</id>
    <published>2022-11-09T05:37:44.000Z</published>
    <updated>2022-11-09T06:02:13.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Explain"><a href="#关于-Explain" class="headerlink" title="关于 Explain"></a>关于 Explain</h2><p>Explain 查询字段的含义</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>该语句的唯一标识</td></tr><tr><td>select_type</td><td>查询类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>type</td><td>联接类型</td></tr><tr><td>possible_keys</td><td>可能的索引选择</td></tr><tr><td>key</td><td>实际选择的索引</td></tr><tr><td>key_len</td><td>索引的长度</td></tr><tr><td>ref</td><td>索引的哪一列被引用了</td></tr><tr><td>rows</td><td>估计要扫描的行</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>该语句的唯一标识, 如果 explain 的结果包括多个 id 的值, 则数字越大越先执行; 对于相同 id 的行, 则表示从上向下依次执行</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>查询类型, 具体如下表 :</p><table><thead><tr><th>查询类型</th><th>作用</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单查询(未使用 UNION 或子查询)</td></tr><tr><td>PRIMARY</td><td>最外层查询</td></tr><tr><td>UNION</td><td>在 UNION 中的第二个和随后的 SELECT 被标记为 UNION</td></tr><tr><td>DEPENDENT UNION</td><td>UNION 中的第二个或后面的查询, 依赖了外面的查询</td></tr><tr><td>UNION RESULT</td><td>UNION 的结果</td></tr><tr><td>SUBQUERY</td><td>子查询中的第一个 SELECT</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>子查询中的第一个 SELECT , 依赖了外面的查询</td></tr><tr><td>DERIVED</td><td>用来表示包含在 FROM 子句的子查询中的 SELECT , MySQL 会递归执行并将结果放到一个临时表中 (MySQL 内部将其称为 Derived table 派生表, 因为该表是从子查询中派生出来的)</td></tr><tr><td>DEPENDENT DERIVED</td><td>派生表, 依赖了其他的表</td></tr><tr><td>MATERIALIZED</td><td>物化子查询</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>子查询, 结果无法缓存, 必须针对外部查询的每一行重新评估</td></tr><tr><td>UNCACHEABLE UNION</td><td>UNION 属于 UNCACHEABLE SUBQUERY 的第二个或后面的查询</td></tr></tbody></table><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示当前这一行正在访问哪张表, 如果 SQL 定义了别名, 则展示表的别名</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>联接类型, 取值如下 (性能由好到坏排序) :</p><ul><li><strong>system</strong> : 该表只有一行(相当于系统表), system 是 const 类型的特例</li><li><strong>const</strong> : 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据; const 查询速度非常快, 因为仅仅读取一次即可</li><li><strong>eq_ref</strong> : 当使用了索引的全部组成部分, 并且索引是 PRIMARY KEY 或 UNIQUE NOT NULL 才会使用该类型, 性能仅次于 system 和 const</li><li><strong>ref</strong> : 当满足索引的最左前缀规则, 或者索引不是主键也不是唯一索引时才会发生, 如果使用的索引只会匹配到少量的行, 性能也是不错的</li><li><strong>tips</strong> : 最左前缀原则, 指索引按最左优先的方式匹配索引</li><li><strong>fulltext</strong> : 全文索引</li><li><strong>ref_or_null</strong> : 该类型类似 ref , 但是 MySQL 会额外搜索哪些行包含了 null, 常见于解析子查询</li><li><strong>index_merge</strong> : 表示使用索引合并优化, 表示一个查询里面用到了多个索引</li><li><strong>unique_subquery</strong> : 类似 eq_ref , 但是使用了 IN 查询, 且子查询是主键或者唯一索引</li><li><strong>index_subquery</strong> : 和 unique_subquery 类似, 只是子查询使用的是唯一索引</li><li><strong>range</strong> : 范围扫描, 表示检索了指定范围的行, 主要用于有限制的索引扫描</li><li><strong>index</strong> : 全索引扫描, 和 ALL 类似, 只不过 index 是全盘扫描了索引的数据. 当查询仅使用索引中的一部分时, 可使用此类型, 有两种情况会触发 :<ul><li>如果索引是查询的覆盖索引, 并且索引查询的数据就可以满足查询中所需的所有数据,则只扫描索引树. 此时, explain 的 Extra 列的结果是 Using index. index 通常比 ALL 快, 因为索引的大小通常小于表数据</li><li>按索引的顺序来查找数据行, 执行了全表扫描. 此时, explain 的 Extra 列的结果不会出现 Uses index</li></ul></li><li><strong>ALL</strong> : 全表扫描, 性能最差</li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>展示当前查询可以使用那些索引, 这一列的数据是在优化过程的早期创建的, 因此有些索引可能对于后续优化过程是没用的</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>表示 MySQL 实际选择的索引</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>索引使用的字节数, 由于存储格式, 当字段允许为 NULL 时, key_len 比不允许为空时大 1 字节<br>关于 key_len 的计算 : <a href="https://www.cnblogs.com/gomysql/p/4004244.html">key_len 计算</a></p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>表示将哪个字段或常量和 key 列所使用的字段进行比较</p><p>如果 ref 是一个函数, 则使用的值是函数的结果, 如果想查看是哪个函数, 可以在 EXPLAIN 语句后添加 SHOW WARNING 语句</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>MySQL 估算会扫描的行数, 数值越小越好</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>主要包括 Using filesort 、Using temporary 、Using index、Using where、Using join buffer、impossible where、select tables optimized away、distinct</p><ul><li>Using filesort : 说明 MySQL 会对数据使用一个外部的索引排序, 而不是按照表内的索引顺序进行读取; MySQL 中无法利用索引完成的排序操作称为 “文件排序”</li><li>Using temporary : 使用了临时表保存中间结果, MySQL 在对查询结果排序时使用临时表; 常见于排序 order by 和分组 group by</li><li>Using index : 表示相应 select 操作中使用了覆盖索引, 避免回表; 如果同时出现 Using where, 表明索引被用来执行索引键值的查找; 如果没有出现 Using where, 表明索引只是用来读取数据而非利用索引执行查找</li><li>Using where : 表明使用 where 过滤</li><li>Using join buffer : 表明使用了连接缓存</li><li>impossible where : where 的子句值总是 false</li><li>select tables optimized away : 在没有 group by 子句的情况下, 基于索引优化 min&#x2F;max 操作或者对于 MyIsam 引擎, 优化 count(*) 操作, 不必等到执行阶段进行计算, 直接查询执行计划生成的阶段完成优化</li><li>distinct : 优化 distinct 操作, 在找到第一匹配的元组后即停止找同样值的动作</li><li>……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-Explain&quot;&gt;&lt;a href=&quot;#关于-Explain&quot; class=&quot;headerlink&quot; title=&quot;关于 Explain&quot;&gt;&lt;/a&gt;关于 Explain&lt;/h2&gt;&lt;p&gt;Explain 查询字段的含义&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;t</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 关于时间的一些思考</title>
    <link href="http://logerjava.github.io/2022/11/09/MySQL-%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://logerjava.github.io/2022/11/09/MySQL-%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2022-11-09T05:36:42.000Z</published>
    <updated>2022-11-09T06:02:26.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-DateTime-和-Timestamp"><a href="#关于-DateTime-和-Timestamp" class="headerlink" title="关于 DateTime 和 Timestamp"></a>关于 DateTime 和 Timestamp</h2><h3 id="从时区方面考虑"><a href="#从时区方面考虑" class="headerlink" title="从时区方面考虑"></a>从时区方面考虑</h3><p>DateTime 没有时区信息, DateTime 在保存时保存的是当前会话所设置的时区对应的时间, 当时区更换会导致数据库读取时间出错<br>Timestamp 存在时区信息, Timestamp 会跟随服务器的时区变化而变化, 自动换算成对应时间, 不同时区查询的时间是不同的</p><h3 id="从占用空间-时间范围方面考虑"><a href="#从占用空间-时间范围方面考虑" class="headerlink" title="从占用空间, 时间范围方面考虑"></a>从占用空间, 时间范围方面考虑</h3><p>DateTime 耗费的空间更大, Timestamp 占用 4 个字节的存储空间, DateTime 占用 8 个字节的存储空间, 因此 Timestamp 表示的时间范围更小</p><ul><li>DateTime : 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp : 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h2 id="不要使用字符串存储时间"><a href="#不要使用字符串存储时间" class="headerlink" title="不要使用字符串存储时间"></a>不要使用字符串存储时间</h2><p>使用字符串存储时间占用的空间更大, 效率较低(需要逐个字符对比), 无法使用相关函数进行计算和比较</p><h2 id="不建议使用-int-和-bigint-表示时间"><a href="#不建议使用-int-和-bigint-表示时间" class="headerlink" title="不建议使用 int 和 bigint 表示时间"></a>不建议使用 int 和 bigint 表示时间</h2><p>此种存储方式拥有 Timestamp 类型具有的优点, 并且使用 int 和 bigint 进行日期排序和对比操作会更有效率, 跨系统也没有什么问题, 但是可读性很差, 无法看到具体时间</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述, 是关于 MySQL 中时间的一些思考, 可以看出关于 MySQL 的时间选择实际没有一种特定的最优解, 根据不同的业务场景应选择最适合的存储方法, 下面是各种类型的对比 : </p><table><thead><tr><th>日期类型</th><th>存储空间</th><th>日期格式</th><th>日期范围</th><th>是否存在时区问题</th></tr></thead><tbody><tr><td>DateTime</td><td>8 字节</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>是</td></tr><tr><td>Timestamp</td><td>4 字节</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</td><td>否</td></tr><tr><td>时间戳</td><td>4 字节</td><td>全数字</td><td>1970-01-01 00:00:01 之后的时间</td><td>否</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-DateTime-和-Timestamp&quot;&gt;&lt;a href=&quot;#关于-DateTime-和-Timestamp&quot; class=&quot;headerlink&quot; title=&quot;关于 DateTime 和 Timestamp&quot;&gt;&lt;/a&gt;关于 DateTime 和 Tim</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 高性能优化</title>
    <link href="http://logerjava.github.io/2022/11/09/MySQL-%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://logerjava.github.io/2022/11/09/MySQL-%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2022-11-09T05:35:31.000Z</published>
    <updated>2022-11-09T06:02:19.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库命令规范"><a href="#数据库命令规范" class="headerlink" title="数据库命令规范"></a>数据库命令规范</h2><ol><li>数据库对象名称使用小写字母, 下划线分割</li><li>数据库对象名称禁止使用 MySQL 关键字</li><li>数据库对象名称做到见名识意, 不要超过 32 字符</li><li>临时库表以 tmp_ 前缀, 日期为后缀; 备份表以 bak_ 为前缀, 日期为后缀</li><li>存储相同数据的列名和列类型必须一致</li></ol><h2 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h2><h3 id="1-所有表均使用-Innodb-存储引擎"><a href="#1-所有表均使用-Innodb-存储引擎" class="headerlink" title="1. 所有表均使用 Innodb 存储引擎"></a>1. 所有表均使用 Innodb 存储引擎</h3><p>在没有特殊需求的情况下(即 Innodb 无法满足的功能), 所有表必须使用 Innodb 存储引擎</p><h3 id="2-数据库和表的字符集统一使用-UTF8"><a href="#2-数据库和表的字符集统一使用-UTF8" class="headerlink" title="2. 数据库和表的字符集统一使用 UTF8"></a>2. 数据库和表的字符集统一使用 UTF8</h3><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集</p><h3 id="3-所有表和字段都需要添加注释"><a href="#3-所有表和字段都需要添加注释" class="headerlink" title="3. 所有表和字段都需要添加注释"></a>3. 所有表和字段都需要添加注释</h3><h3 id="4-尽量控制单表数据量大小在-500-万以内"><a href="#4-尽量控制单表数据量大小在-500-万以内" class="headerlink" title="4. 尽量控制单表数据量大小在 500 万以内"></a>4. 尽量控制单表数据量大小在 500 万以内</h3><p>单表数据量过大, 在修改表结构, 进行表备份, 恢复等操作时会出现问题, 可以通过分库分表手段控制表大小</p><h3 id="5-谨慎使用分区表"><a href="#5-谨慎使用分区表" class="headerlink" title="5. 谨慎使用分区表"></a>5. 谨慎使用分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表, 谨慎选择分区键，跨分区查询效率可能更低, 建议采用物理分表的方式管理大数据</p><h3 id="6-条件允许尽量冷热数据分离-减小表宽度"><a href="#6-条件允许尽量冷热数据分离-减小表宽度" class="headerlink" title="6. 条件允许尽量冷热数据分离, 减小表宽度"></a>6. 条件允许尽量冷热数据分离, 减小表宽度</h3><p>MySQL 限制单表最多存储 4096 列, 并且每一行数据的大小不能超过 65535 字节<br>减少磁盘 IO, 表越宽, 将表加载到内存缓冲池时所占用的内存也就越大, 会消耗更多的 IO , 保证热数据的内存缓存命中率, 更有效的利用缓存, 避免读入无用的冷数据, 经常一起使用的列可以放到一个表中(避免过多的关联操作)</p><h3 id="7-禁止在表中建立预留字段"><a href="#7-禁止在表中建立预留字段" class="headerlink" title="7. 禁止在表中建立预留字段"></a>7. 禁止在表中建立预留字段</h3><p>预留字段的命名很难做到见名识义, 预留字段无法确认存储的数据类型，所以无法选择合适的类型, 对预留字段类型的修改，会对表进行锁定</p><h3 id="8-禁止在数据库中存储图片-文件等大的二进制数据"><a href="#8-禁止在数据库中存储图片-文件等大的二进制数据" class="headerlink" title="8. 禁止在数据库中存储图片, 文件等大的二进制数据"></a>8. 禁止在数据库中存储图片, 文件等大的二进制数据</h3><p>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时,通常存储于文件服务器，数据库只存储文件地址信息</p><h3 id="9-禁止在生产库做压力测试"><a href="#9-禁止在生产库做压力测试" class="headerlink" title="9. 禁止在生产库做压力测试"></a>9. 禁止在生产库做压力测试</h3><h3 id="10-禁止在开发-测试环境直接连接生产环境数据库"><a href="#10-禁止在开发-测试环境直接连接生产环境数据库" class="headerlink" title="10. 禁止在开发, 测试环境直接连接生产环境数据库"></a>10. 禁止在开发, 测试环境直接连接生产环境数据库</h3><h2 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h2><h3 id="1-优先选择符合存储需要的最小的数据类型"><a href="#1-优先选择符合存储需要的最小的数据类型" class="headerlink" title="1. 优先选择符合存储需要的最小的数据类型"></a>1. 优先选择符合存储需要的最小的数据类型</h3><p>列的字段越大, 建立索引时所需要的空间也就越大, 这样一页中所能存储的索引节点的数量也就越少, 在遍历时需要的 IO 次数也就越多, 索引性能也就越差</p><p>example :</p><ul><li>将字符串转换为数字类型存储(ip 地址转换为整型数据)<br> MySQL 提供了两个方法来处理 ip 地址<br> <strong>inet_aton</strong> 把ip转为无符号整型(4-8位)<br> <strong>inet_ntoa</strong> 把整型的ip转为地址<br> 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间, 显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可</li><li>对于非负型的数据（如自增 id、整型 ip）来说，要优先使用无符号整型来存储<br> 因为, 无符号相对于有符号可以多出一倍的存储空间<br> SIGNED INT -2147483648<del>2147483647<br> UNSIGNED INT 0</del>4294967295<br> VARCHAR(N)中的N代表的是字符数，而不是字节数, 使用 UTF8 存储 255 个汉字, Varchar(255)&#x3D;765个字节, 过大的长度会消耗更多的内存</li></ul><h3 id="2-避免使用-TEXT-BLOB-数据类型-最常见的-TEXT-类型可以存储-64k-的数据"><a href="#2-避免使用-TEXT-BLOB-数据类型-最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="2. 避免使用 TEXT, BLOB 数据类型, 最常见的 TEXT 类型可以存储 64k 的数据"></a>2. 避免使用 TEXT, BLOB 数据类型, 最常见的 TEXT 类型可以存储 64k 的数据</h3><p>建议将 BLOB 或 TEXT 列分离到单独的扩展表中 :<br>MySQL 内存临时表不支持 TEXT, BLOB 这样的大数据类型, 如果查询中包含这样的数据, 在排序等操作时, 就不能使用内存临时表, 必须使用磁盘临时表进行, 而且对于这种数据, MySQL 还需要二次查询, 会使 SQL 性能变的很差, 如果一定要使用, 建议将 TEXT, BLOB 放到单独的扩展表, 查询时必要使用 select * , 而是查询指定列, 不需要 TEXT 时不要查询  </p><p>TEXT 或 BLOB 类型只能使用前缀索引 :<br>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的</p><h3 id="3-避免使用-ENUM-类型"><a href="#3-避免使用-ENUM-类型" class="headerlink" title="3. 避免使用 ENUM 类型"></a>3. 避免使用 ENUM 类型</h3><p>修改 ENUM 类型需要使用 ALTER 语句, 并且 ENUM 类型的 ORDER BY 操作效率低, 需要额外操作</p><h3 id="4-尽可能将所有列定义为-NOT-NULL"><a href="#4-尽可能将所有列定义为-NOT-NULL" class="headerlink" title="4. 尽可能将所有列定义为 NOT NULL"></a>4. 尽可能将所有列定义为 NOT NULL</h3><p>索引 NULL 列需要额外的空间来保存, 所以要占用更多的空间, 进行比较和计算时都要对 NULL 值进行特别处理</p><h3 id="5-使用-Timestamp-或-DateTime-存储时间"><a href="#5-使用-Timestamp-或-DateTime-存储时间" class="headerlink" title="5. 使用 Timestamp 或 DateTime 存储时间"></a>5. 使用 Timestamp 或 DateTime 存储时间</h3><p><a href="https://note.youdao.com/ynoteshare/index.html?id=8f38d751a3807ed6d93b50402f3bbfd4&type=note&_time=1666083006278">MySQL - 关于时间问题的一些思考</a></p><h3 id="6-同财务相关的金额类数据必须使用-decimal-类型"><a href="#6-同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="6. 同财务相关的金额类数据必须使用 decimal 类型"></a>6. 同财务相关的金额类数据必须使用 decimal 类型</h3><p>float, double 为非精准浮点, decimal 是精准浮点, decimal 在计算时不会丢失精度, 占用空间由定义宽度决定, 每 4 个字节可以存储 9 位数字(小数点要占用 1 字节), 可存储比 bigint 更大的整型数据</p><h2 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h2><h3 id="1-限制每张表的索引数量-建议的单张表不超过-5-个"><a href="#1-限制每张表的索引数量-建议的单张表不超过-5-个" class="headerlink" title="1. 限制每张表的索引数量, 建议的单张表不超过 5 个"></a>1. 限制每张表的索引数量, 建议的单张表不超过 5 个</h3><p>索引并不是越多越好, 我们知道索引可以增加查询效率, 但是如果使用存在问题索引会降低写入的效率, 有些情况也会降低查询效率  </p><p>MySQL 优化器在选择如何优化查询时, 会根据统一信息, 对每一个可以用到的索引进行评估,生成一个最好的执行计划, 如果同时有很多个索引都可以用于查询, 就会增加 MySQL 优化器生成执行计划的时间, 降低查询性能</p><h3 id="2-禁止给表中的每一列都建立单独的索引"><a href="#2-禁止给表中的每一列都建立单独的索引" class="headerlink" title="2. 禁止给表中的每一列都建立单独的索引"></a>2. 禁止给表中的每一列都建立单独的索引</h3><p>5.6 版本之前，一个 SQL 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</p><h3 id="3-Innodb-表必须存在主键"><a href="#3-Innodb-表必须存在主键" class="headerlink" title="3. Innodb 表必须存在主键"></a>3. Innodb 表必须存在主键</h3><p>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的<br>每个表都可以有多个索引，但是表的存储顺序只能有一种<br>Innodb是按照主键索引的顺序来组织表的</p><p>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）<br>不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长）<br>主键建议使用自增ID值</p><h2 id="索引列建议"><a href="#索引列建议" class="headerlink" title="索引列建议"></a>索引列建议</h2><ol><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>多表 JOIN 的关联列</li></ol><p>条件合适的情况下建立联合索引, 避免每个单独列都建立索引</p><h2 id="索引顺序问题"><a href="#索引顺序问题" class="headerlink" title="索引顺序问题"></a>索引顺序问题</h2><p>索引建立的目的是 : 通过索引进行数据查找, 减少随机 IO, 增加查询性能, 索引能过滤出越少的数据则从磁盘中读取的数据也就越少</p><ol><li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）</li><li>尽量将字段长度小的列放在联合索引的最左侧（字段长度越小，一页能存储的数据量越大，IO性能也就越好）</li><li>使用最频繁的列放到联合索引最左侧（较少的建立一些索引）</li></ol><h2 id="避免建立冗余索引和重复索引"><a href="#避免建立冗余索引和重复索引" class="headerlink" title="避免建立冗余索引和重复索引"></a>避免建立冗余索引和重复索引</h2><p>原因 : 增加查询优化器生成执行计划的时间  </p><p>重复索引示例：primary key(id)、index(id)、unique index(id)<br>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</p><h2 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h2><p>原因 :  </p><ol><li>避免 Innodb 表进行索引的二次查询  </li><li>可以将随机 IO 变为顺序 IO 加快查询速度</li></ol><p>详情 : <a href="https://mp.weixin.qq.com/s/quDi0AV7Fw20wOSQ6Rb_gA">MySQL - 索引机制</a></p><h2 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h2><h3 id="1-建议使用预编译语句进行数据库操作"><a href="#1-建议使用预编译语句进行数据库操作" class="headerlink" title="1. 建议使用预编译语句进行数据库操作"></a>1. 建议使用预编译语句进行数据库操作</h3><p>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题, 只传参数，比传递 SQL 语句更高效, 相同语句可以一次解析，多次使用，提高处理效率</p><h3 id="2-避免数据类型隐式转换"><a href="#2-避免数据类型隐式转换" class="headerlink" title="2. 避免数据类型隐式转换"></a>2. 避免数据类型隐式转换</h3><p>隐式转换会导致索引失效, 在单次查询数据很多的情况下, 若查询列隐式转换将会降低效率</p><h3 id="3-充份利用已建立的索引"><a href="#3-充份利用已建立的索引" class="headerlink" title="3. 充份利用已建立的索引"></a>3. 充份利用已建立的索引</h3><p>example :</p><ul><li>避免使用双 % 的查询条件<br> 如 name like %loger% , 若无前置 % 只有后置 % , 是可以用到列上的索引的</li><li>一个 SQL 只能利用到复合索引中的一列进行查询<br> 如有 a, b, c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b, c 列上的索引将不会被用到，在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧</li><li>使用 LEFT JOIN 或 NOT EXISTS 来优化 NOT IN 操作<br> NOT INT 会导致索引失效</li></ul><h3 id="4-数据库设计时-需考虑后续扩展情况"><a href="#4-数据库设计时-需考虑后续扩展情况" class="headerlink" title="4. 数据库设计时, 需考虑后续扩展情况"></a>4. 数据库设计时, 需考虑后续扩展情况</h3><h3 id="5-程序连接不同数据库使用不同账号-进行跨库查询"><a href="#5-程序连接不同数据库使用不同账号-进行跨库查询" class="headerlink" title="5. 程序连接不同数据库使用不同账号, 进行跨库查询"></a>5. 程序连接不同数据库使用不同账号, 进行跨库查询</h3><p>为数据库迁移和分库分表留出余地, 降低业务耦合度, 避免权限过大而产生的安全风险</p><h3 id="6-禁止使用-SELECT"><a href="#6-禁止使用-SELECT" class="headerlink" title="6. 禁止使用 SELECT *"></a>6. 禁止使用 SELECT *</h3><p>消耗更多的 CPU 和 IO 以网络带宽资源, 无法使用覆盖索引, 可以减少表结构变更带来的影响</p><h3 id="7-禁止使用不含字段列表的-INSERT-语句"><a href="#7-禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="7. 禁止使用不含字段列表的 INSERT 语句"></a>7. 禁止使用不含字段列表的 INSERT 语句</h3><p>如： insert into values (‘a’,’b’,’c’);<br>应使用 insert into t(c1,c2,c3) values (‘a’,’b’,’c’);</p><h3 id="8-避免使用子查询-可以将子查询优化为-JOIN-操作"><a href="#8-避免使用子查询-可以将子查询优化为-JOIN-操作" class="headerlink" title="8. 避免使用子查询, 可以将子查询优化为 JOIN 操作"></a>8. 避免使用子查询, 可以将子查询优化为 JOIN 操作</h3><p>通常子查询在 IN 子句中, 且子查询为简单 SQL (不包含 union、group by、order by、limit 从句) 时, 才可以将子查询转化为关联查询进行优化</p><p>子查询性能差的原因 :<br>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响, 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大, 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询</p><h3 id="9-避免使用-JOIN-关联太多表"><a href="#9-避免使用-JOIN-关联太多表" class="headerlink" title="9. 避免使用 JOIN 关联太多表"></a>9. 避免使用 JOIN 关联太多表</h3><p>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置<br>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，<br>所占用的内存也就越大</p><p>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，<br>就会影响到服务器数据库性能的稳定性</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率<br>Mysql最多允许关联61个表，建议不超过5个</p><h3 id="10-减少同数据库交互次数"><a href="#10-减少同数据库交互次数" class="headerlink" title="10. 减少同数据库交互次数"></a>10. 减少同数据库交互次数</h3><p>数据库更适合处理批量操作, 合并多个相同的操作在一起, 可以提高处理效率</p><h3 id="11-对应同一列进行-OR-判断时-使用-IN-替代-OR"><a href="#11-对应同一列进行-OR-判断时-使用-IN-替代-OR" class="headerlink" title="11. 对应同一列进行 OR 判断时, 使用 IN 替代 OR"></a>11. 对应同一列进行 OR 判断时, 使用 IN 替代 OR</h3><p>IN 的值不要超过 500 个<br>IN 操作可以更有效的利用索引，OR 大多数情况下很少能利用到索引</p><h3 id="12-禁止使用-ORDER-BY-RAND-进行随机排序"><a href="#12-禁止使用-ORDER-BY-RAND-进行随机排序" class="headerlink" title="12. 禁止使用 ORDER BY RAND() 进行随机排序"></a>12. 禁止使用 ORDER BY RAND() 进行随机排序</h3><p>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，<br>就会消耗大量的CPU和IO及内存资源</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式</p><h3 id="13-WHERE-从句中禁止对列进行函数转换和计算"><a href="#13-WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="13. WHERE 从句中禁止对列进行函数转换和计算"></a>13. WHERE 从句中禁止对列进行函数转换和计算</h3><p>会导致索引失效</p><h3 id="14-在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#14-在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3><p>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作<br>UNION ALL 不会再对结果集进行去重操作</p><h3 id="15-拆分复杂的大-SQL-为多个小-SQL"><a href="#15-拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="15. 拆分复杂的大 SQL 为多个小 SQL"></a>15. 拆分复杂的大 SQL 为多个小 SQL</h3><p>大SQL:逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL, MySQL 一个 SQL 只能使用一个 CPU 进行计算, SQL 拆分后可以通过并行执行来提高处理效率</p><h2 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h2><h3 id="超-100-万的批量写操作-要分批次进行操作"><a href="#超-100-万的批量写操作-要分批次进行操作" class="headerlink" title="超 100 万的批量写操作, 要分批次进行操作"></a>超 100 万的批量写操作, 要分批次进行操作</h3><ol><li>大批量操作可能会造成严重的主从延迟<br> 主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</li><li>binlog 日志为 row 格式时会产生大量日志<br> 大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</li><li>避免产生大事务操作<br> 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响, 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</li></ol><h3 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h3><ol><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ol><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的</p><p>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器, 把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉, 把原来一个 DDL 操作，分解成多个小的批次进行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库命令规范&quot;&gt;&lt;a href=&quot;#数据库命令规范&quot; class=&quot;headerlink&quot; title=&quot;数据库命令规范&quot;&gt;&lt;/a&gt;数据库命令规范&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;数据库对象名称使用小写字母, 下划线分割&lt;/li&gt;
&lt;li&gt;数据库对象名称禁止使用 My</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型详解</title>
    <link href="http://logerjava.github.io/2022/11/08/Java-%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://logerjava.github.io/2022/11/08/Java-%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-11-08T08:23:12.000Z</published>
    <updated>2022-11-09T06:06:34.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。</strong></p><p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;loger&quot;</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; list.size();i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)list.get(i);</span><br><span class="line">    log.info(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>ArrayList 中可以存放任意类型, 当上述情况, 其中即存在 <code>Integer</code> 又存在 <code>String</code>, 且都以 <code>String</code> 的方式使用时, 程序就会报错, 泛型可以解决此类问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>声明带泛型的集合, 在集合内类型不匹配时, 会直接报错</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>泛型只在编辑阶段有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">classStringArrayList</span> <span class="operator">=</span> stringArrayList.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">classIntegerArrayList</span> <span class="operator">=</span> integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    log.info(<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>类型相同</code></p><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说 Java 中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处 T 可以使用任意表示, T、E、K、V 均可</span></span><br><span class="line"><span class="comment">// 实例化时必须指定 T 的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt; &#123;    </span><br><span class="line"><span class="comment">// T 的类型为外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入实参的类型与泛型相同, 如不做泛型限制, 则会根据传入实参做相应限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型限制</span></span><br><span class="line">Test&lt;String&gt; stringTest = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="string">&quot;loger&quot;</span>);</span><br><span class="line">Test&lt;Integer&gt; integerTest = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">333</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非限制</span></span><br><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">33.33</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span>&lt;T&gt; &#123;    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口未传入实参时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class TestImpl&lt;T&gt; implements Test&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class TestImpl implements Test&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Test</span>&lt;T&gt;&#123;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，传入泛型实参时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口 Test&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为 T 传入无数个实参，形成无数种类型的 Test 接口</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：TestImpl&lt;T&gt;，public T next();中的的T都要替换成传入的 String 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImpl</span> <span class="keyword">implements</span> <span class="title class_">Test</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>试想一个问题 <code>Integer</code> 是 <code>Number</code> 的一个子类, 而 <code>Test&lt;Integer&gt;</code> 和 <code>Test&lt;Number&gt;</code> 实际上是相同的基本类型, 那么 <code>Test&lt;Number&gt;</code> 作为形参的方法中, 能否使用 <code>Test&lt;Ingeter&gt;</code> 实例传入呢 ?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showValue</span><span class="params">(Test&lt;Number&gt; arg)</span> &#123;</span><br><span class="line">    log.info(arg.getKey());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;Integer&gt; integerTest = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">Test&lt;Number&gt; numberTest = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showValue(integerTest);</span><br></pre></td></tr></table></figure><p>很明显编译的时候就报错了 <code>Test&lt;java.lang.Integer&gt; cannot be applied to Test&lt;java.lang.Number&gt;</code> 由此可以看出: <strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong></p><p>在处理上述问题时, 可以将泛型替换为 <code>?</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showValue</span><span class="params">(Test&lt;?&gt; arg)</span> &#123;</span><br><span class="line">    log.info(arg.getKey());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, 此处 <code>?</code> 代表的是类型实参, 而非形参, 换一种说话就是可以把 <code>?</code> 看成所有类的父类, 它可以解决当具体类型不确定时, <code>?</code> 即是通配符</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间 &lt;T&gt; 非常重要, 可以理解为声明此方法为泛型方法</span></span><br><span class="line"><span class="comment"> *     2）只有声明了 &lt;T&gt; 的方法才是泛型方法, 泛型类中的使用了泛型的成员方法并不是泛型方法</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt; 表明该方法将使用泛型类型 T , 此时才可以在方法中使用泛型类型 T</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样, 此处 T 可以随便写为任意标识, 常见的如 T、E、K、V 等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showVale</span><span class="params">(Test&lt;? extends Number&gt; test)</span>&#123;</span><br><span class="line">    log.info(obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就规定了泛型的上边界, 传入的类型实参必须是指定类型的子类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt; test1 = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;String&gt;(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">Test&lt;Integer&gt; test2 = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Test&lt;Float&gt; test3 = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Test&lt;Double&gt; test4 = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Double&gt;(<span class="number">2.56</span>);</span><br></pre></td></tr></table></figure><p>在编译时, test1 会报错, 因为 String 并不是 Number 的子类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思</summary>
      
    
    
    
    
    <category term="Java" scheme="http://logerjava.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从复制</title>
    <link href="http://logerjava.github.io/2022/11/08/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://logerjava.github.io/2022/11/08/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2022-11-08T05:32:44.000Z</published>
    <updated>2022-11-09T06:02:32.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ol><li><p>当 Master 节点进行 insert、update、delete 操作时，会按顺序写入到 binlog 中</p></li><li><p>salve 从库连接 master 主库，Master 有多少个 slave 就会创建多少个 binlog dump 线程</p></li><li><p>当 Master 节点的 binlog 发生变化时，binlog dump 线程会通知所有的 salve 节点，并将相应的 binlog 内容推送给 slave 节点</p></li><li><p>I&#x2F;O 线程接收到 binlog 内容后，将内容写入到本地的 relay-log</p></li><li><p>SQL 线程读取 I&#x2F;O 线程写入的 relay-log，并且根据 relay-log   的内容对从数据库做对应的操作</p></li></ol><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/MySQLCopyTheory.png" alt="主从原理"></p><p>这里有很重要的两个问题 : </p><ul><li>从库同步主库数据的过程是串行化的, 也就是说主库上并行的操作, 在从库上会串行化执行, 由于从库从主库拷贝日志以及串行执行 SQL 的特点, 在高并发场景下, 从库的数据势必会比主库慢, 存在延迟, 所以经常出现刚写入主库的数据读不到的情况</li><li>如果主库突然宕机, 此时数据还没有同步到从库, 那么有些数据从库上是没有的, 会出现数据丢失情况</li></ul><p>MySQL 存在两个机制解决上面的问题 :</p><ul><li>半同步复制 : 主要解决主库数据丢失问题, 也叫做 semi-sync 复制, 指主库写入 binlog 日志之后, 就会强制将此时的数据立即同步到从库, 从库将日志写入自己本地的 relay log 之后, 返回一个 ack 给主库, 主库接收到至少一个从库的 ack 才会认为写操作完成了</li><li>并行复制 : 主要解决同步延时问题, 指从库开启多线程, 并行读取 relay log 中不同库的日志, 然后并行重放不同库的日志, 这是库级别的并行</li></ul><h2 id="如何实现主从复制"><a href="#如何实现主从复制" class="headerlink" title="如何实现主从复制"></a>如何实现主从复制</h2><p>这里举例是一主一从</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>登录 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>创建用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10.1.30.113 是 slave 从机的 IP</span></span><br><span class="line">GRANT REPLICATION SLAVE ON *.* to &#x27;root&#x27;@&#x27;10.1.30.113&#x27; identified by &#x27;1qaz@WSX&#x27;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新系统权限表的配置</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>在 etc&#x2F;my.cnf 增加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启binlog</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=114</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要同步的数据库，如果不配置则同步全部数据库</span></span><br><span class="line">binlog-do-db=test_db</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">binlog日志保留的天数，清除超过10天的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防止日志文件过大，导致磁盘空间不足</span></span><br><span class="line">expire-logs-days=10</span><br></pre></td></tr></table></figure><p>重启 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p>通过下方命令查看当前 binlog 日志信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status\G;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/MasterShow.png" alt="MasterShow"></p><h3 id="Slave"><a href="#Slave" class="headerlink" title="Slave"></a>Slave</h3><p>在 etc&#x2F;my.cnf 增加以下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不要和其他mysql服务<span class="built_in">id</span>重复即可</span></span><br><span class="line">server-id=114</span><br></pre></td></tr></table></figure><p>登录 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>输入以下命令 : </p><p>MASTER_HOST : 主机 IP</p><p>MASTER_USER: 之前创建的用户账号</p><p>MASTER_PASSWORD : 之前创建的用户密码</p><p>MASTER_LOG_FILE : master 主机的 binlog 日志名称</p><p>MASTER_LOG_POS : binlog 日志偏移量</p><p>master_port : 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;10.1.30.114&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;1qaz@WSX&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000007&#x27;,MASTER_LOG_POS=862,master_port=3306;</span><br></pre></td></tr></table></figure><p>重新启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>启动下方命令校验</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/SlaveShow.png" alt="SlaveShow"></p><p>判断同步成功方式 :</p><ol><li>首先 Master_Log_File 和 Relay_Master_Log_File 所指向的文件必须一致</li><li>其次 Relay_Log_Pos 和 Exec_Master_Log_Pos 的为止也要一致才行</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_role` (</span><br><span class="line">  `role_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">  `state` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;1启用0停用,默认0&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`role_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>在 master 执行上述 SQL 同步到 slave , 表示配置成功</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/MySQLCopyResoultShow.png" alt="MySQLCopyResoultShow"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>配置失败出现的问题常见于 Slave_IO_Running: No 或 Slave_SQL_Running: No , 通常是配置读取文件出现问题或事务回滚造成的主从问题, 由于问题很多不做赘述, 列举几个类似问题的博客 :</p><p><a href="https://blog.csdn.net/zzddada/article/details/113352717">https://blog.csdn.net/zzddada/article/details/113352717</a></p><p><a href="https://blog.csdn.net/weixin_30657999/article/details/99613614">https://blog.csdn.net/weixin_30657999/article/details/99613614</a></p><p><a href="https://blog.csdn.net/lihuarongaini/article/details/101299375">https://blog.csdn.net/lihuarongaini/article/details/101299375</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主从复制原理&quot;&gt;&lt;a href=&quot;#主从复制原理&quot; class=&quot;headerlink&quot; title=&quot;主从复制原理&quot;&gt;&lt;/a&gt;主从复制原理&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当 Master 节点进行 insert、update、delete 操作时，会按顺序写入</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://logerjava.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>为什么要使用消息队列, 优缺点, 各消息队列对比</title>
    <link href="http://logerjava.github.io/2022/11/07/whyMQ/"/>
    <id>http://logerjava.github.io/2022/11/07/whyMQ/</id>
    <published>2022-11-07T07:53:14.000Z</published>
    <updated>2022-11-09T06:02:44.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%A7%A3%E8%80%A6.png" alt="jieou"></p><p>如上方场景, A 系统通过接口调用方式发送数据到 B, C, D 系统, 此时新增 E 系统也需要此数据该如何解决 ? 此时又新增了其他系统呢 ? B 系统在某个时间节点不需要 A 系统的数据了该如何解决 ?</p><p>在上方场景中 A 系统不仅和 B, C, D 等系统严重耦合在一起, 并且要时刻考虑其他系统的状态, 如果宕机是否要重新发送, 是否需要存储消息等, 负责人的讲 A 系统负责人会很痛苦</p><p>如果改用 MQ 方式处理, A 系统产生数据, 直接发送到 MQ 中, 其余需要数据的系统到 MQ 中消费, B 系统不需要则取消消费, 这种情况下 A 系统就摆脱了束缚, 无需考虑调用是否成功, 是否超时等问题, 如下图</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E8%A7%A3%E8%80%A62.png" alt="jieou2"></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%BC%82%E6%AD%A5.png" alt="yibu"></p><p>如上场景, 假设 A 系统接收到用户请求需要本地持久化数据, 过程为 3ms, 后 B, C, D 写库总计 3 + 300 + 450 + 200 &#x3D; 953ms, 总体接近 1s, 在一般的项目中我们要求基本上是请求响应基本上是对用户无感知的, 大概 200ms 以内完成, 以上情况很难接受</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%BC%82%E6%AD%A52.png" alt="yibu2"></p><p>此时添加 MQ, A 系统发送三条消息到 MQ 中耗时 5ms, 总计 3 + 5 &#x3D; 8ms, 直接返回后续操作在后台完成</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>考虑如下场景, 从早晨 0:00 开始到下午 13:00, 系统 A 每秒并发请求基本维持在 30 左右, 在 13:00 到 14:00 每秒请求激增到 5k+, 系统基于 MySQL 直连, 这时会有每秒 5k+ 的请求打入数据库</p><p>一般的 MySQL 很明显无法抗住这种请求级别, 2k 左右大概是极限, 很可能直接宕机, 用户也就无法继续操作系统, 但是经过高峰期后又再度恢复为每秒 30 的请求量</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%89%8A%E5%B3%B0.png" alt="xuefeng"></p><p>这个时候我们考虑接入 MQ 处理, 每秒 5k+ 的请求写入 MQ, 系统 A 每秒至多处理 2k 的请求, 那么就仅拉取 2k 的请求, 只要不超过处理极限就可以, 这样在最高峰值期间服务并不会挂掉, 每秒 5k 左右的请求进入 MQ, 2k 左右的请求被消费, 这样可能会导致几十万甚至百万的请求积压在 MQ 中, 但是短暂的积压是没有关系的, 经历过高峰期后只有每秒 30 的请求量, 但是系统还是在按照每秒 2k 左右的速度消费, 高峰期过后用不了多久就可以处理结束</p><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E5%89%8A%E5%B3%B02.png" alt="xuefeng2"></p><h2 id="消息队列的优缺点"><a href="#消息队列的优缺点" class="headerlink" title="消息队列的优缺点"></a>消息队列的优缺点</h2><p>优点 :</p><ul><li>解耦, 异步, 削峰</li></ul><p>缺点 :</p><ul><li>可用性降低 : 系统引入的外部依赖越多则可用性越低, 根据上面的场景, 本身是 A, B, C, D 四个系统的问题, 接入 MQ 后需要考虑 MQ 的维护问题, 如果 MQ 宕机则整套系统都将崩溃</li><li>复杂度提高 : 新增 MQ 后需要考虑消息幂等问题(是否重复), 消息丢失问题, 顺序等</li><li>一致性问题 : 在将消息发送到 MQ 后返回成功, 但是不一定真的全部成功, 有可能 B, C 写入成功而 D 却失败等问题, 会导致数据不一致</li></ul><p>综上所属消息队列实际上并没有想象的那么简单, 引入消息队列确实可以带来好处, 但是也会衍生出另一些问题, 针对某些必要使用 MQ 的场景我们需要提前准备问题的解决方案, 难度系统直线上升, 但是关键时刻消息队列是起决定性作用的技术, 该用还是要用</p><h2 id="ActiveMQ、RabbitMQ、RocketMQ、Kafka-对比"><a href="#ActiveMQ、RabbitMQ、RocketMQ、Kafka-对比" class="headerlink" title="ActiveMQ、RabbitMQ、RocketMQ、Kafka 对比"></a>ActiveMQ、RabbitMQ、RocketMQ、Kafka 对比</h2><table><thead><tr><th></th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>以前很多人用 ActiveMQ , 但是现在用的很少, 并且社区不活跃, 不建议使用</p><p>RabbitMQ 社区很活跃, 但是 erlang 语言导致 RabbitMQ 处于基本不可控的状态, 也无法做到自定义</p><p>RocketMQ 来自阿里, 质量有保证, 毕竟有双 11 检验, 但是目前 RocketMQ 已经捐献给 <a href="https://github.com/apache/rocketmq">Apache</a>, 并且活跃度不是很高, 不过毕竟是 Java 写的可控性还是有的, 如果对公司技术自信的可以考虑</p><p>Kafka 一般适用于大数据领域, 日志采集, 实时计算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么使用消息队列&quot;&gt;&lt;a href=&quot;#为什么使用消息队列&quot; class=&quot;headerlink&quot; title=&quot;为什么使用消息队列&quot;&gt;&lt;/a&gt;为什么使用消息队列&lt;/h2&gt;&lt;h3 id=&quot;解耦&quot;&gt;&lt;a href=&quot;#解耦&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="消息队列" scheme="http://logerjava.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
