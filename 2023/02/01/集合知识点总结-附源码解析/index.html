<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>集合知识点总结(附源码解析) | logerJava</title>
  <meta name="description" content="概览ListArrayList ：  底层为数组实现，查找访问效率高，增删效率较低 每次扩容为原来的 1.5 倍，默认初始化容量为 10 增删效率低的原因是因为，需要进行 navite 方法的数组拷贝复制 线程不安全  LinkedList ：  底层双向链表实现，随机访问效率低，增删效率高  Vector ：  底层数组实现，现在比较少用 Vector 的所有方法均为synchronized修饰">
<meta property="og:type" content="article">
<meta property="og:title" content="集合知识点总结(附源码解析)">
<meta property="og:url" content="http://logerjava.github.io/2023/02/01/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E9%99%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="logerJava">
<meta property="og:description" content="概览ListArrayList ：  底层为数组实现，查找访问效率高，增删效率较低 每次扩容为原来的 1.5 倍，默认初始化容量为 10 增删效率低的原因是因为，需要进行 navite 方法的数组拷贝复制 线程不安全  LinkedList ：  底层双向链表实现，随机访问效率低，增删效率高  Vector ：  底层数组实现，现在比较少用 Vector 的所有方法均为synchronized修饰">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png">
<meta property="og:image" content="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png">
<meta property="og:image" content="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A83.png">
<meta property="og:image" content="https://raw.githubusercontent.com/logerJava/los/main/picture/1.7ConcurrentHashMap.png">
<meta property="og:image" content="https://raw.githubusercontent.com/logerJava/los/main/picture/1.8ConcurrentHashMap.png">
<meta property="article:published_time" content="2023-02-01T02:30:03.000Z">
<meta property="article:modified_time" content="2023-02-02T05:45:51.514Z">
<meta property="article:author" content="loger">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://logerjava.github.io/2023/02/01/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E9%99%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
  
    <link rel="alternate" href="/atom.xml" title="logerJava" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/logerJava" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">loger</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Software Engineer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/logerJava" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>最近在转移公众号文章到博客, 想看更多目前建议去公众号或者访问 github 的 loger 项目有文章目录</p> <img src="/images/logerJava.png" width="200" height="200">
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nacos/" rel="tag">Nacos</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/" rel="tag">Tools</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 13.67px;">MySQL</a> <a href="/tags/Nacos/" style="font-size: 13px;">Nacos</a> <a href="/tags/Tools/" style="font-size: 13px;">Tools</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 13px;">消息队列</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/02/01/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E9%99%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="title">集合知识点总结(附源码解析)</a>
              </p>
              <p class="item-date">
                <time datetime="2023-02-01T02:30:03.000Z" itemprop="datePublished">2023-02-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/11/11/LiteFlow-%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%A7%A3%E8%80%A6/" class="title">LiteFlow 复杂业务逻辑解耦</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-11T02:31:01.000Z" itemprop="datePublished">2022-11-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/11/11/GroovyClassLoader-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81/" class="title">GroovyClassLoader 从字符串中加载解析代码</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-11T02:28:39.000Z" itemprop="datePublished">2022-11-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/11/09/KeyTool-%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9/" class="title">KeyTool 工具生成密钥对</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-09T05:56:50.000Z" itemprop="datePublished">2022-11-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/11/09/Linux-%E5%AE%89%E8%A3%85-JDK/" class="title">Linux 安装 JDK</a>
              </p>
              <p class="item-date">
                <time datetime="2022-11-09T05:56:00.000Z" itemprop="datePublished">2022-11-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-集合知识点总结-附源码解析" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      集合知识点总结(附源码解析)
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/02/01/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E9%99%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
	  <time datetime="2023-02-01T02:30:03.000Z" itemprop="datePublished">2023-02-01</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/Java/" rel="tag">Java</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/02/01/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E9%99%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 17(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>ArrayList ：</p>
<ul>
<li>底层为数组实现，查找访问效率高，增删效率较低</li>
<li>每次扩容为原来的 <strong>1.5</strong> 倍，默认初始化容量为 10</li>
<li>增删效率低的原因是因为，需要进行 navite 方法的数组拷贝复制</li>
<li>线程不安全</li>
</ul>
<p>LinkedList ：</p>
<ul>
<li>底层双向链表实现，随机访问效率低，增删效率高</li>
</ul>
<p>Vector ：</p>
<ul>
<li>底层数组实现，现在比较少用</li>
<li>Vector 的所有方法均为synchronized修饰，性能损耗较大</li>
<li>Vector 初始 length 是 10 超过 length 时以 100% 比率增长（2 倍），相比于 ArrayList 消耗更多的内存</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>TreeSet ：</p>
<ul>
<li>基于红黑树实现，支持有序性操作</li>
<li>查找效率不如 HashSet</li>
</ul>
<p>HashSet ：</p>
<ul>
<li>基于哈希表实现，支持快速查找，不支持有序性操作</li>
</ul>
<p>LinkedHashSet ：</p>
<ul>
<li>具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>HashMap ：</p>
<ul>
<li>基于哈希表实现</li>
</ul>
<p>TreeMap ：</p>
<ul>
<li>基于红黑树实现</li>
</ul>
<p>HashTable ：</p>
<ul>
<li>与 HashMap 类似，但是其线程安全，同一时刻多线程同时写入 HashTable 不会导致数据不一致，但是不建议使用遗留类，若想使用线程安全的 Map 建议使用 ConcurrentHashMap</li>
</ul>
<p>LinkedHashMap ：</p>
<ul>
<li>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</li>
</ul>
<h2 id="源码分析及拓展"><a href="#源码分析及拓展" class="headerlink" title="源码分析及拓展"></a>源码分析及拓展</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入add方法分别分为四部分：</p>
<ul>
<li>首先进入 <code>add()</code> 方法，为了得到最小的容量，避免资源浪费，这里用了 size + 1 确认一下 +1 后是否满足我们的需求</li>
<li>在 <code>ensureExplicitCapacity(int minCapacity)</code> 方法中判断 <code>minCapacity - elementData.length &gt; 0</code> 如果添加容量大于最小容量则调用 <code>grow()</code> 进行扩容</li>
<li>在 <code>grow()</code>方法中将，新容量 &#x3D; 旧容量 + 旧容量右移1位 <code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> 此处相当于1.5倍扩容</li>
<li>然后调用 <code>copyOf()</code> 方法，复制指定数组</li>
</ul>
<p>可以看到，需要进行扩容就需要调用 <code>Arrays.copyOf()</code> 将原数组整个复制到新数组中，此操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少需要的扩容次数</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove方法的实现步骤：</p>
<ul>
<li>先检查角标是否越界</li>
<li>删除掉指定元素</li>
<li>因为 ArrayList 是数组的数据结构，所以需要计算出要移动的个数，将后面的向前移动</li>
<li>将 <code>elementData[--size]</code> 设为 null，来让 GC 回收</li>
</ul>
<p>需要调用 <code>System.arraycopy()</code> 将 index+1 后面的元素都复制到 index 位置上，我查了一下该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p>
<blockquote>
<p><strong>elementData[–size] 为什么要设为 null ？</strong></p>
<p>这个问题首先要了解 GC 回收的原理，GC 回收采用可达性分析算法，通过 GC Roots 到节点是否可达来进行对象的回收。回到问题，删除一个元素后，numMoved 长度的数组元素，要向前移动，很明显移动过后 list 中的数组长度减少了 1。所以此处将多出的这个引用，也就是 elementData[–size] 设为 null ， 让 GC 可以正确回收内存，并且 size 自身减少1后可以保证 size 属性可以返回 list 所需要的正确数组长度。</p>
<p>我们可以举一个具体的例子，比如此处为 0、1、2、3、4、5 现在我想 remove 掉下标为 1 的元素，此处变为 0、2、3、4、5、5 最后的 5 依旧存在，所以将它设为 null 进行释放。</p>
</blockquote>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vector 的实现与 ArrayList 类似，但是使用了 synchronized 进行同步</p>
<h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在调用没有 capacityIncrement 参数的构造函数时，capacityIncrement 值默认为 0，也就是说默认情况下 Vector 每次扩容的容量都会翻倍</p>
<h4 id="同-ArrayList-的比较"><a href="#同-ArrayList-的比较" class="headerlink" title="同 ArrayList 的比较"></a>同 ArrayList 的比较</h4><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢，最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己控制</li>
<li>Vector 每次扩容请求其大小的 <strong>2</strong> 倍，而 ArrayList 是 <strong>1.5</strong> 倍</li>
</ul>
<h4 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h4><p>可以使用 <code>Collections.synchronizedList()</code> 得到一个线程安全的 ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失</p>
<p>写操作结束之后需要把原始数组指向新的复制数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>CopyOnWriteArrayList 在写操作的同时允许读操作的进行，这样大大提高了读的性能，因此很适合读多写少的应用场景</p>
<p>但是 CopyOnWriteArrayList 也存在缺陷 ：</p>
<ul>
<li>内存占用 ：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右</li>
<li>数据不一致 ：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="同-ArrayList-的比较-1"><a href="#同-ArrayList-的比较-1" class="headerlink" title="同 ArrayList 的比较"></a>同 ArrayList 的比较</h4><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别 ：</p>
<ul>
<li>数组支持随机访问，但插入删除代价很高，需要移动大量元素</li>
<li>链表不支持随机访问，但插入删除只需要改变指针</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>JDK 1.8 以前 ：HashMap 的数据结构为<strong>数组+链表</strong>实现的，数组中存储了 key-value 的键值对（Entry），在进行插入操作时会根据 key 的 hash 计算出 index 值表示在数组中插入的位置，而 hash 存在概率性，不同的 key 计算 hash 出的 index 可能是一样的，这样就形成了链表</p>
<p>JDK 1.8 及之后 ：HashMap 的数据结构为<strong>数组+链表+红黑树</strong>，当链表长度超过 8 时会自动转为红黑树，小于 6 时重新变为链表</p>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p>在 JDK 1.8 以前，采用头插法处理链表插入问题</p>
<p>例如实例化如下 HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16&#x3D;3</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6，插在 &lt;K2,V2&gt; 前面</li>
</ul>
<p>链表指针顺序为 k3 -&gt; k2</p>
<h4 id="环形链表问题"><a href="#环形链表问题" class="headerlink" title="环形链表问题"></a>环形链表问题</h4><p>环形链表问题是 JDK 1.8 HashMap 将链表插入从头插法变为尾插法的主要原因</p>
<p>假设有一个容量大小为 2 的 HashMap，负载因子 0.75，现将插入 α、β、γ 三个数据 key 为 1、2、3</p>
<p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81.png" alt="环形链表1"></p>
<p>因为扩容机制的原因，上述图片其实并不可能发生，事实上在插入第二个元素时就会进行扩容，因为 JDK 1.7 采用头插法的原因，新加入的元素会放在链表的头部，又因为经过 rehash 后同一链表上的元素可能被放到数组的其他位置，所以可能会变成下面的样子</p>
<p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82.png" alt="环形链表2"></p>
<p>可以发现指针位置是可能发生改变的，此时我们带入多线程的场景，用不同的线程操作分别插入 1、2、3 因为头插法更换指针的原因，可能就会变成下面的样子</p>
<p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A83.png" alt="环形链表3"></p>
<p>因为头插法会改变链表的顺序，在多线程场景下，就有可能会出现环形链表的问题，陷入无限循环</p>
<h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p>在 JDK 1.8 及之后，采用尾插法处理链表插入问题</p>
<p>例如实例化如下 HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16&#x3D;3</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16&#x3D;6，插在 &lt;K2,V2&gt; 后面</li>
</ul>
<p>链表指针顺序为 k2 -&gt; k3，并且在扩容后不会改变链表顺序，所以尾插法并不会出现环形链表问题</p>
<h4 id="扩容-基本原理"><a href="#扩容-基本原理" class="headerlink" title="扩容 - 基本原理"></a>扩容 - 基本原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// table 的容量大小，默认为 16, 需要注意的是 capacity 必须保证为 2 的 n 次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size; <span class="comment">// 键值对数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold; <span class="comment">// size 的临界值,当 size 大于等于 threshold 就必须进行扩容操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor; <span class="comment">// 装载因子, table 能够使用的比例, threshold = (int)(capacity* loadFactor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要扩容时，令 capacity 为原来的两倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步很费时</p>
<h4 id="扩容-重新计算桶下标"><a href="#扩容-重新计算桶下标" class="headerlink" title="扩容 - 重新计算桶下标"></a>扩容 - 重新计算桶下标</h4><p>在进行扩容时，需要将键值对重新计算桶下标，从而放到对应桶上，HashMap 计算桶下标方法如下，HashMap capacity 为 2^n 这一特点能够极大降低重新计算桶下标的复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设原数组长度为 16，扩容之后 new capacity 为 32</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure>

<p>对于一个 key 值，它的哈希值在第 5 位 ：</p>
<ul>
<li>为 0 时，hash % 00010000 &#x3D; hash % 00100000，桶位置和原来一致</li>
<li>为 1 时，hash % 00010000 &#x3D; hash % 00100000 + 16，桶位置是原位置加16</li>
</ul>
<h4 id="扩容-计算数组容量"><a href="#扩容-计算数组容量" class="headerlink" title="扩容 - 计算数组容量"></a>扩容 - 计算数组容量</h4><p>HashMap 构造函数允许用户传入容量为非 2^n 的情况，因为它可以自动将传入容量转换为 2^n</p>
<p>先考虑如何求一个数的掩码，对于 10000000 其掩码为 11111111，可以使用如下方法 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> num</span><br><span class="line">mask |= mask &gt;&gt; <span class="number">1</span>  <span class="number">11000000</span>  <span class="comment">// 将num右移一位得到 0100 0000，然后与原始的num(1000 0000)进行或运算，得到mask（1100 000）</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">2</span>  <span class="number">11110000</span>  <span class="comment">// 将刚得到的mask再右移一位得到 0011 0000，然后与上一步得到的mask(1100 0000)进行或运算，得到新mask（1110 0000）</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">4</span>  <span class="number">11111111</span>  <span class="comment">// 我们再次将刚得到的mask右移4位，得到0000 1111,然后与上一步得到的mask进行与运算，得到1111 1111</span></span><br></pre></td></tr></table></figure>

<p>mask + 1 是大于原始数字的最小的 2^n</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num     <span class="number">10000000</span></span><br><span class="line">mask+<span class="number">1</span>  <span class="number">100000000</span></span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同-Hashtable-的对比"><a href="#同-Hashtable-的对比" class="headerlink" title="同 Hashtable 的对比"></a>同 Hashtable 的对比</h4><ul>
<li>Hashtable 使用 synchronized 来进行同步</li>
<li>HashMap 可以插入键为 null 的 Entry</li>
<li>HashMap 的迭代器是 fail-fast 迭代器</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/1.7ConcurrentHashMap.png"></p>
<p>在 JDK 1.8 以前 ConcurrentHashMap 和 HashMap 实现上类似，主要差别在于 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），也就是说 ConcurrentHashMap 的底层实现为 Segments + HashEntry 数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Segment 继承自 ReentrantLock，查看源码的话还可以发现对每个 Segment 都有进行单独加锁的操作, 我们也可以这样认为 Segment 的个数为锁的并发度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCAN_RETRIES</span> <span class="operator">=</span></span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>HashEntry 虽然用来存储键值对但是和 HashMap 并不是相同的, 因为 HashEntry 采用 volatile 字段修饰了 value 和 指向下一节点的 next, 确保了可见性, 这也是为什么 ConcurrentHashMap 高效的原因之一, 因为 volatile 原因导致它的 get 方法根本不用加锁</p>
<p>JDK 1.7 的 ConcurrentHashMap 采用 CAS 方式更新 baseCount 来确保线程安全, 如果失败则必定存在线程竞争关系, 此时会调用 <code>scanAndLockForPut()</code> 方法自旋获取锁, 在其内部存在 MAX_SCAN_RETRIES 可以理解为最大重试次数, 如果达到了则改为阻塞锁获取, 确保修改成功</p>
<p><img src="https://raw.githubusercontent.com/logerJava/los/main/picture/1.8ConcurrentHashMap.png"></p>
<p>在 JDK 1.8 时, ConcurrentHashMap 放弃了分段锁, 取而代之的类似于 HashMap 的数组 + 链表 + 红黑树结构，采取 CAS + Synchronized 的方式来保证线程安全，put 操作流程如下 ：</p>
<ul>
<li>首先根据 key 计算出 hashCode</li>
<li>判断是否需要进行初始化操作</li>
<li>根据 key 定位到 Node (1.7 中的 HashEntry), 如果是 null 则表示当前位置可以写入数据, CAS 操作写入, 若失败则自旋确保成功</li>
<li>如果当前的 hashCode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1, 则表示需要扩容</li>
<li>若都不满足, 就利用 Synchronized 锁写入数据</li>
<li>若数据大于 TREEIFY_THRESHOLD, 也就是大于 8 就转为红黑树</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://logerjava.github.io/2023/02/01/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E9%99%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="集合知识点总结(附源码解析)" target="_blank" rel="external">http://logerjava.github.io/2023/02/01/集合知识点总结-附源码解析/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/logerJava" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/logerJava" target="_blank"><span class="text-dark">loger</span><small class="ml-1x">Java Software Engineer</small></a></h3>
        <div>人来人往, 云卷云舒</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/2022/11/11/LiteFlow-%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%A7%A3%E8%80%A6/" title="LiteFlow 复杂业务逻辑解耦"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/logerJava" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'kmLjKgtX3vudmyRtKLryzPgu-gzGzoHsz',
    appKey: 'Lw1W6K30cBzNmbdUSbRo1CGa',
    placeholder: '欢迎提出您的意见',
    avatar: 'hide',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>